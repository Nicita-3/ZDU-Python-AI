# –ù–∞–ø–∏—à—ñ—Ç—å –ø–æ–∫—Ä–æ–∫–æ–≤—É –≥—Ä—É, —è–∫–∞ –¥–æ–∑–≤–æ–ª—è—î –ø–æ—Å–∞–¥–∏—Ç–∏ –Ω–∞ –ø–ª–∞–Ω–µ—Ç—É
# –∫–æ—Å–º—ñ—á–Ω–∏–π –∫–æ—Ä–∞–±–µ–ª—å. –ì—Ä–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—î —Å–æ–±–æ—é —Å–µ—Ä—ñ—é –∫—Ä–æ–∫—ñ–≤, –¥–ª—è —è–∫–∏—Ö —Ç—Ä–µ–±–∞
# –≤–≤–æ–¥–∏—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–æ—ó —Ç–æ—á–∫–∏, –¥–æ —è–∫–æ—ó –º–∞—î –ø–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏—Å—è
# –∫–æ—Ä–∞–±–µ–ª—å.
# –ü–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è –∫–æ—Ä–∞–±–ª—è, –ø–ª–∞–Ω–µ—Ç–∏ —Ç–∞ –ø–µ—Ä–µ—à–∫–æ–¥ –∑–∞–¥–∞—î—Ç—å—Å—è
# –ø—Å–µ–≤–¥–æ–≥—Ä–∞—Ñ—ñ—á–Ω–∏–º —Å–∏–º–≤–æ–ª—å–Ω–∏–º —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º —ñ –≤–∏–≤–æ–¥–∏—Ç—å—Å—è –Ω–∞ –µ–∫—Ä–∞–Ω –∑
# –∫–æ–∂–Ω–∏–º –∫—Ä–æ–∫–æ–º.
# –ì—Ä–∞–≤–µ—Ü—å –≤–∏–≥—Ä–∞—î, —è–∫—â–æ –∫–æ—Å–º—ñ—á–Ω–∏–π –∫–æ—Ä–∞–±–µ–ª—å –∑–∞—Ö–æ–¥–∏—Ç—å –≤ –∞—Ç–º–æ—Å—Ñ–µ—Ä—É
# –ø–ª–∞–Ω–µ—Ç–∏ (–æ–∫—ñ–ª –Ω–∞ 1 –±—ñ–ª—å—à–∏–π –∑–∞ —Ä–æ–∑–º—ñ—Ä –ø–ª–∞–Ω–µ—Ç—É).
# –ö–æ—Å–º—ñ—á–Ω–∏–π –∫–æ—Ä–∞–±–µ–ª—å —Ä–æ–∑–±–∏–≤–∞—î—Ç—å—Å—è –æ–± –ø–µ—Ä–µ—à–∫–æ–¥—É, —è–∫—â–æ –ø–æ–ø–∞–¥–∞—î —É
# –æ–¥–∏–Ω–∏—á–Ω–∏–π —ó—ó –æ–∫—ñ–ª –∞–±–æ –Ω–∞ —Å–∞–º—É –ø–µ—Ä–µ—à–∫–æ–¥—É –∞–±–æ –∂ –π–æ–≥–æ –ª—ñ–Ω—ñ–π–Ω–∏–π —à–ª—è—Ö
# –ø–µ—Ä–µ—Ç–∏–Ω–∞—î —Ü—é –ø–µ—Ä–µ—à–∫–æ–¥—É —á–∏ —ó—ó –æ–∫—ñ–ª.
# –ö–æ—Å–º—ñ—á–Ω–∏–π –∫–æ—Ä–∞–±–µ–ª—å –∑–∞–π–º–∞—î –æ–¥–Ω–µ —ñ–≥—Ä–æ–≤–µ –ø–æ–ª–µ 1*1, –ø–µ—Ä–µ—à–∫–æ–¥–∏ (–¥–æ —á–æ—Ç–∏—Ä—å–æ—Ö –Ω–∞ –≥—Ä—É)
# –º–∞—é—Ç—å –≤–∞—Ä—ñ–∞—Ç–∏–≤–Ω—ñ —Ä–æ–∑–º—ñ—Ä–∏ –∫–≤–∞–¥—Ä–∞—Ç—ñ–≤ –≤—ñ–¥ 1*1 –¥–æ 3*3,
# —Ä–æ–∑–º—ñ—Ä–∏ –ø–ª–∞–Ω–µ—Ç–∏ –≤–∞—Ä—ñ—é—é—Ç—å—Å—è –≤—ñ–¥ 4*4 –¥–æ 5*5.
# –ú—ñ–∂ –ø–µ—Ä–µ—à–∫–æ–¥–∞–º–∏ –º–∞—î –±—É—Ç–∏ –≤—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–Ω—ñ–º—É–º 3 –∫–ª—ñ—Ç–∏–Ω–∫–∏.
# –†–æ–∑–º—ñ—â–µ–Ω–Ω—è –≤—Å—ñ—Ö —ñ–≥—Ä–æ–≤–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ –∑–∞–¥–∞—î—Ç—å—Å—è –≤–∏–ø–∞–¥–∫–æ–≤–∏–º —á–∏–Ω–æ–º –Ω–∞ –ø–æ—á–∞—Ç–∫—É –≥—Ä–∏.
# –†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –º–∞—î –±—É—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –û–û–ü.
import sys, io
import os
import random
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
renderX = 70 # min 30+-
renderY = 30 # min 20+-


class Rocket:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.d = 1
        self.textures = [["üöÄ"]]

    
class Planet:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.d = random.randint(4, 5)
        self.textures = [["üü©" for i in range(self.d)] for i in range(self.d)]

class Obstacle:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.d = random.randint(1, 3)
        self.textures = [["üü®" for i in range(self.d)] for i in range(self.d)]

class Render:
    def __init__(self, w, h):
        self.w = w
        self.h = h
        self.objs = []

    def __str__(self):
        screen = [["  " for _ in range(self.w)] for _ in range(self.h)]
        for obj in self.objs:
            for i in range(obj.d):
                for j in range(obj.d):
                    symbol = obj.textures[i][j]
                    if symbol.strip():
                        y = obj.y + i
                        x = obj.x + j
                        if 0 <= x < self.w and 0 <= y < self.h:
                            screen[y][x] = symbol

        top_numbers = "   " + "".join(f"{i%10:2}" for i in range(self.w))
        lines = [top_numbers]

        for idx, row in enumerate(screen):
            lines.append(f"{idx:2} " + "".join(row))

        return "\n".join(lines)
    
    def clear():
        os.system('cls' if os.name == 'nt' else 'clear')

# –Ü–Ω–ø—É—Ç –∫–æ—Ä–¥
def getCordsToStr(string):
    try:
        strCords = input(string)
        numbers = [int(x) for x in strCords.split()]
        return {
            "x": numbers[0],
            "y": numbers[1]
        }
    except ValueError:
        print("–ü–û–ú–ò–õ–ö–ê –í–í–û–î–£! –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑...")
        return getCordsToStr(string)

# –Ü–Ω–ø—É—Ç —á–∏—Å–ª–∞
def getInt(string, min, max):
    try:
        k = int(input("–í–≤–µ–¥—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–µ—Ä–µ—à–∫–æ–¥ –≤—ñ–¥ 1 –¥–æ 4: "))
        if k < min or k > max:
            print("–ü–û–ú–ò–õ–ö–ê –í–í–û–î–£! –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑...")
            return getInt(string, min, max)
        else:
            return k
    except ValueError:
        print("–ü–û–ú–ò–õ–ö–ê –í–í–û–î–£! –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑...")
        return getInt(string, min, max)

def generateObstacleCoords(num, w, h, min_distance=3, max_size=3):
    coords = []

    i = 0
    max_i = 1000
    while len(coords) < num and i < max_i:
        size = random.randint(1, max_size)
        x = random.randint(0, w - size - 1)
        y = random.randint(0, h - size - 1)

        ok = True
        for ox, oy, od in coords:
            if abs(x - ox) < od + size + min_distance and abs(y - oy) < od + size + min_distance:
                ok = False
                break

        if ok:
            coords.append((x, y, size))

        i += 1

    return coords


# –ú–µ–Ω–µ–¥–∂–µ—Ä —ñ–Ω–ø—É—Ç—É ‚Ññ2
def startDefaultGame():
    data = {
        "rocket": None,
        "planet": None,
        "obstacles": []
    }
    data["rocket"] = Rocket(renderX // 2, 0)
    data["planet"] = Planet(renderX // 2, renderY - 3)

    obstacle_coords = generateObstacleCoords(4, renderX, renderY)

    for x, y, size in obstacle_coords:
        obs = Obstacle(x, y)
        obs.d = size
        obs.textures = [["üü®" for _ in range(size)] for _ in range(size)]
        data["obstacles"].append(obs)

    return data

# –ú–µ–Ω–µ–¥–∂–µ—Ä —ñ–Ω–ø—É—Ç—É
def startGame():
    data = {
        "rocket": None,
        "planet": None,
        "obstacles": []
    }
    rocketCords = getCordsToStr("–í–≤–µ–¥—ñ—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∫–æ—Ä–∞–±–ª—è x y: ")
    data["rocket"] = Rocket(rocketCords["x"], rocketCords["y"])
    planetCords = getCordsToStr("–í–≤–µ–¥—ñ—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –ø–ª–∞–Ω–µ—Ç–∏ x y: ")
    data["planet"] = Planet(planetCords["x"], planetCords["y"])
    k = getInt("–í–≤–µ–¥—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–µ—Ä–µ—à–∫–æ–¥ –≤—ñ–¥ 1 –¥–æ 4: ", 1, 4)
    i = 1
    while (i <= k):
        obstacleCords = getCordsToStr(f"–í–≤–µ–¥—ñ—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –ø–µ—Ä–µ—à–∫–æ–¥–∏ ‚Ññ{i} x y: ")
        data["obstacles"].append(Obstacle(obstacleCords["x"], obstacleCords["y"]))
        i += 1
    return data

# game = startGame()
game = startDefaultGame()

def is–°ollision(x, y, obstacles):
    for obs in obstacles:
        if (obs.x - 1 <= x <= obs.x + obs.d) and (obs.y - 1 <= y <= obs.y + obs.d):
            return True
    return False

def isPathBlocked(x1, y1, x2, y2, obstacles):
    dx = x2 - x1
    dy = y2 - y1
    steps = max(abs(dx), abs(dy))
    if steps == 0:
        return is–°ollision(x1, y1, obstacles)
    for i in range(steps + 1):
        xi = x1 + round(i * dx / steps)
        yi = y1 + round(i * dy / steps)
        if is–°ollision(xi, yi, obstacles):
            return True
    return False

def isPlanetReached(x, y, planet):
    if (planet.x - 1 <= x <= planet.x + planet.d) and (planet.y - 1 <= y <= planet.y + planet.d):
        return True
    return False

r = Render(renderX, renderY)
r.objs.append(game["planet"])
r.objs.extend(game["obstacles"])
r.objs.append(game["rocket"])

prev_x = game["rocket"].x
prev_y = game["rocket"].y

Render.clear()
print(r)

while True:
    rocketCords = getCordsToStr(f"–í–≤–µ–¥—ñ—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∫–æ—Ä–∞–±–ª—è x({prev_x}) y({prev_y}) (–º—ñ–Ω—É—Å –¥–ª—è –≤–∏—Ö–æ–¥—É): ")

    x = rocketCords["x"]
    y = rocketCords["y"]
    if x < 0 or y < 0:
        print("–í–∏—Ö—ñ–¥ –∑ –≥—Ä–∏...")
        break

    if isPathBlocked(prev_x, prev_y, x, y, game["obstacles"]):
        print("–ö–æ—Ä–∞–±–µ–ª—å —Ä–æ–∑–±–∏–≤—Å—è –æ–± –ø–µ—Ä–µ—à–∫–æ–¥—É! üí•üí•üí•üí•üí•üí•")
        break

    
    game["rocket"].x = x
    game["rocket"].y = y

    if isPlanetReached(x, y, game["planet"]):
        Render.clear()
        print(r)
        print("–£—Å–ø—ñ—à–Ω–∞ –ø–æ—Å–∞–¥–∫–∞ –Ω–∞ –ø–ª–∞–Ω–µ—Ç—É!")
        break

    Render.clear()
    print(r)

    prev_x = x
    prev_y = y